





`timescale 1ns/1ps

module top (
    input wire clk,
    input wire rst_n,
    input wire valid_in,
    input wire signed [7:0] in_data,
    input wire signed [7:0] weight,

    // 額外輸入：為了讓 pooling 有效，模擬一組 9 筆輸入
    input wire signed [7:0] pool_in0,
    input wire signed [7:0] pool_in1,
    input wire signed [7:0] pool_in2,
    input wire signed [7:0] pool_in3,
    input wire signed [7:0] pool_in4,
    input wire signed [7:0] pool_in5,
    input wire signed [7:0] pool_in6,
    input wire signed [7:0] pool_in7,
    input wire signed [7:0] pool_in8,

    output wire signed [7:0] relu_out,
    output wire signed [7:0] pool_out,
    output wire pool_valid
);

    // 中間訊號
    wire signed [15:0] conv_out;  // Conv 模組 16 位元輸出
    wire conv_valid;

    // --- 模組實例化 ---

    // 1. convolution PE
    conv_pe #(.DATA_WIDTH(8)) u_conv_pe (
        .clk(clk),
        .rst_n(rst_n),
        .in_data(in_data),
        .weight(weight),
        .valid_in(valid_in),
        .out_data(conv_out),
        .valid_out(conv_valid)
    );

    // 2. ReLU (16 位元輸入，保持精度輸出 16 位元)
    relu #(.WIDTH(16)) u_relu (
        .din(conv_out),  // 16 位元輸入
        .dout(relu_out)  // 16 位元輸出
    );

    // 3. Pooling (用 ReLU 結果作為輸入，注意池化層只能接受 8 位元數據)
    // 將 relu_out 拆成 8 位元數據傳入池化層
    pooling u_pooling (
        .clk(clk),
        .rst_n(rst_n),
        .valid_in(valid_in), // 可改為其他 valid 條件
        .data_in0(relu_out[7:0]),  // 提取低 8 位元
        .data_in1(relu_out[7:0]),  // 提取低 8 位元
        .data_in2(relu_out[7:0]),  // 提取低 8 位元
        .data_in3(relu_out[7:0]),  // 提取低 8 位元
        .data_in4(relu_out[7:0]),  // 提取低 8 位元
        .data_in5(relu_out[7:0]),  // 提取低 8 位元
        .data_in6(relu_out[7:0]),  // 提取低 8 位元
        .data_in7(relu_out[7:0]),  // 提取低 8 位元
        .data_in8(relu_out[7:0]),  // 提取低 8 位元
        .max_out(pool_out),
        .valid_out(pool_valid)
    );

endmodule
